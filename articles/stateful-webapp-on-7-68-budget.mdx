---
title: "Making A Stateful Webapp on a $7.68 per Month Budget"
date: "2023-02-15"
thumbnail: "/thumbnails/stateful-webapp-on-budget.png"
thumbnailAlt: "A screenshot of makemetouchgrass.com"
description: "My reflections on making a stateful webapp at minimal cost, using Python, NextJS, and PostgreSQL."
tags: ["python", "nextjs", "fastapi", "postgresql"]
---
## Backends Are Useful, But Scary

A backend handles user data for a website.
Most websites need a backend, because they need to be dynamicâ€”it's not enough
to show the same page to every visitor.
Visitors need to interact with the website:
whether it's checking out an order on Amazon or posting a hot take on Twitter.

This blog, however, has no backend. It shows the same page to every visitor, and 
will not handle any user data. It is static.
This reduces my hosting costs, because the entire blog can be cached in a 
CDN (Content Delivery Network)
like Cloudflare, for free.
Using a CDN provides faster load times and increased reliability.

Historically I've avoided making webapps with backends for my hobby projects.
A backend comes with all sorts of baggage: databases, managing user data,
authentication, backups, and increased server load.
This complexity adds cost to a project: both in time and hosting costs.
So I've avoided them when possible.

Normally, when I couldn't get away with providing a static frontend,
I've avoided the issue by writing software meant to be run by the user
on their own computer.
But this limits the accessibility of my projects to technical users who
are familiar with linux and a command line interface.
The benefit of a webapp is that anyone can use it.

When my girlfriend pitched me an idea for a webapp to help her organize her life and help 
compete with the digital temptations that weren't bringing her value,
I decided to face my apprehension of backends.

We decided to call this project [Make Me Touch Grass](https://makemetouchgrass.com).

## Tools

To get the project up and running quickly, I reached for tools that were familiar to me:
Python, NextJS, and Docker.

### Backend

To further accelerate development, I relied on the Python web framework FastAPI [^ fastapi],
which provides most of the base functionality needed for setting up a backend.
I had no prior experience working with this 
framework, but found it beneficial.

The FastAPI OAuth2 tutorial [^ fastapi-oauth2] was especially helpful for quickly setting up authentication
for my backend.
There's no room for error in this part of the system, in order to protect user data.
The tutorial allowed me to quickly set up API endpoints
for registering new users, logging in, and retrieving user data.
With FastAPI, this was done in only 100 lines of Python.

### Frontend

NextJS [^ nextjs] provides an opinionated framework built
on top of React, allowing the frontend codebase to scale with added complexity.
I prefer using NextJS over Create React App (another library for setting up React projects),
as in my experience it's has better performance for static deployments.

### Database

While developing, I started out just using in memory data structures for the API at first, then I moved to 
SQLite, a single-file relational database.
Using a relational database allows the backend to safely modify data 
concurrently, and also stores the data more persistently than in-memory data structures.

Then I moved to PostgreSQL after I became concerned
over concurrency constraints of using SQLite.
I haven't used SQLite much professionally, but my understanding
is that because it relies on a single database file, it is better suited to single-user applications
than something with many concurrent users making writes to the database.

### Reverse Proxy

I'm using nginx as a reverse proxy for the system so that the frontend and backend can be accessed at the same 
domain. This helps mitigate CORS issues.

The config for nginx to do this is simple as well.

```
worker_processes 1;
 
events { worker_connections 1024; }
 
http {
    index    index.html;
    root /usr/share/nginx/html/;
    include mime.types;

    sendfile on;
 
    server {
        resolver 127.0.0.11;
        listen 8080 default_server;

        location /api/  {
            proxy_pass      http://backend:4000/;
        }

        location / {
            proxy_pass      http://frontend:80/;
        }
    }
}
```

This forwards all requests to the frontend docker container except requests starting with `/api`,
which are sent to the backend.

### Docker

Because of the numerous dependencies I'm using, Docker was very helpful for tying the whole thing together
and manage dependencies. I'm also using docker compose to manage the networking here, which exposes
each container under the container name by default. This is why the nginx can reference the services 
as `http://backend`

The docker compose file to support this is also quite minimal:

```
services:
    database:
        build: database
        restart: always
        environment:
            - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            - POSTGRES_USER=postgres
            - POSTGRES_DB=postgres
        volumes:
            - database-volume:/var/lib/postgresql/data

    reverseproxy:
        build: reverseproxy
        ports:
            - 8080:8080
        restart: always

    frontend:
        build: web
        depends_on:
            - reverseproxy
        restart: always

    backend:
        depends_on:
            - reverseproxy
            - database
        environment:
            - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        build: backend
        restart: always

volumes:
  database-volume:
    driver: local
    driver_opts:
      type: 'none'
      o: 'bind'
      device: '${PWD}/postgres_data'
```

## Code

I removed all the application-specific parts of the repo and uploaded them
[here](https://github.com/wcedmisten/python-nextjs-template),
so anyone wanting to build a full stack webapp powered by the same tools can
get a head start following the same approach I did.

## Deployment

To actually push this project out into the world, I had to set up some infrastructure.
I chose a $7/month Digital Ocean droplet that bought me just 1 GB of RAM
and a single virtual intel CPU. I have no idea if this will provide enough compute to 
run the project long-term, but for now, this is my budget for the project.

I also bought a domain name (makemetouchgrass.com) for $0.68/month from NameCheap.

To decrease latency and increase reliability for the website, I'm using Cloudflare to 
cache the static assets on a CDN. This is a free service offered by Cloudflare.

So far the base load on my server has been fairly minimal, but I also don't have many
real users yet. I'll have to see how this project scales with more users, and possibly
re-evaluate hosting options.

So far the only issue I've had with this limited server is running builds. Generally
the CPU usage hovers at less than 5%, but during the build step it spikes and really bottlenecks.

![Digital Ocean CPU Usage](/stateful-webapp-on-budget/digitalocean.png)

Memory usage generally stays under 50%, but does also uses a lot for cache. I suspect this 
is the bigger bottleneck.

![htop memory usage](/stateful-webapp-on-budget/memory-usage.png)

As a result of these constraints, I have to take the server down when making updates,
causing downtime for users. This is not ideal, and is the biggest downside I've faced
of such a tight budget. But then again, I don't have many users to begin with.

Generally the build takes around 1 minute, and is noticably slower than when running on my 
local development environment. Running NextJS's export command `next export` is the culprit
here.

### Cloud Hybrid?

I had another idea to mitigate the limited compute available on my budget: run the actual server on 
prem (my home office), and forward the requests from the DigitalOcean droplet that is associated with
my domain name. This approach would involve running the app at my `wcedmisten.dev` personal domain
that's pointing at an unused desktop in my home office. Then I would configure nginx running on 
my DigitalOcean droplet to rewrite all traffic to this subdomain.

This would help solve my memory constraints, because this desktop has 128 GB 
of RAM. Comparatively, even the cheapest 4 GB DigitalOcean droplet is $24/month,
which is more than I want to spend on this project.

## Conclusions and future work

So far, despite my prior hesitation to make a project with a backend, the project has
gone smoothly so far. The real issue is now a need to acquire users and get some 
feedback. If you want to check out the app, please go to
[makemetouchgrass.com](https://makemetouchgrass.com)
and make a free account. I'd love to get your feedback at
[feedback@wcedmisten.fyi](mailto:feedback@wcedmisten.fyi). Thanks!



[^ fastapi]: https://fastapi.tiangolo.com/
[^ fastapi-oauth2]: https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/
[^ nextjs]: https://nextjs.org/
